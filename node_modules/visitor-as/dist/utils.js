import { DeclarationStatement, Source, SourceKind, ClassDeclaration, TypeNode, NodeKind, InterfaceDeclaration, FunctionDeclaration, TypeName, DiagnosticCategory, NamedTypeNode, util, } from "assemblyscript/dist/assemblyscript.js";
import { ASTBuilder } from "./astBuilder.js";
import cloneDeep from "lodash.clonedeep";
// const cloneDeep: <T>(t: T) => T = require("lodash.clonedeep") as any;
export function decorates(node, name) {
    return node.name.text === name;
}
export function isDecorator(name) {
    return (node) => decorates(node, name);
}
export function hasDecorator(node, name) {
    let decl;
    if (node instanceof DeclarationStatement) {
        decl = node;
    }
    else {
        decl = node.declaration;
    }
    // because it could be undefined
    return decl.decorators?.some(isDecorator(name)) == true;
}
export function getDecorator(node, name) {
    return node.decorators?.find(isDecorator(name));
}
export function isLibrary(node) {
    return node.isLibrary || node.internalPath.startsWith("~lib/rt/");
}
export function not(fn) {
    return (t) => !fn(t);
}
export function toString(node) {
    return ASTBuilder.build(node);
}
const OR_NULL = /\|.*null/;
export function getName(node) {
    if (node instanceof TypeNode) {
        if (node instanceof NamedTypeNode) {
            let name = getTypeName(node.name);
            const typeParameters = node.typeArguments;
            if (typeParameters && typeParameters.length > 0) {
                name += `<${typeParameters.map(getName).join(", ")}>`;
            }
            if (node.isNullable && !OR_NULL.test(name)) {
                name = `${name} | null`;
            }
            return name;
        }
        else if (node instanceof TypeName) {
            return toString(node.identifier);
        }
        return "";
    }
    if (node instanceof ClassDeclaration || node instanceof InterfaceDeclaration || node instanceof FunctionDeclaration) {
        return className(node);
    }
    return toString(node.name);
}
export function getTypeName(node) {
    const partNames = [];
    let currentNode = node;
    while (currentNode) {
        partNames.push(toString(currentNode.identifier));
        currentNode = currentNode.next;
    }
    return partNames.join(".");
}
export function cloneNode(node) {
    return cloneDeep(node);
}
export function isUserEntry(node) {
    return node.range.source.sourceKind == SourceKind.USER_ENTRY;
}
export function isEntry(node) {
    return isUserEntry(node) || node.range.source.sourceKind == SourceKind.LIBRARY_ENTRY;
}
export function className(_class) {
    let name = toString(_class.name);
    const typeParameters = _class.typeParameters;
    if (typeParameters) {
        name += `<${typeParameters.map(getName).join(", ")}>`;
    }
    return name;
}
export function isMethodNamed(name) {
    return (stmt) => stmt.kind == NodeKind.METHODDECLARATION && toString(stmt.name) === name;
}
export function updateSource(program, newSource) {
    const sources = program.sources;
    for (let i = 0, len = sources.length; i < len; i++) {
        if (sources[i].internalPath == newSource.internalPath) {
            sources[i] = newSource;
            break;
        }
    }
}
export class StringBuilder {
    sb = [];
    push(s) {
        this.sb.push(s);
    }
    finish(separator = "\n") {
        let res = this.sb.join(separator);
        this.sb = [];
        return res;
    }
    get last() { return this.sb[this.sb.length - 1]; }
}
/**
 *
 * @param emitter DiagnosticEmitter
 * @returns return true if emitter have ERROR message
 */
export function hasErrorMessage(emitter) {
    return hasMessage(emitter, DiagnosticCategory.ERROR);
}
/**
*
* @param emitter DiagnosticEmitter
* @returns return true if emitter have WARNING message
*/
export function hasWarningMessage(emitter) {
    return hasMessage(emitter, DiagnosticCategory.WARNING);
}
/**
*
* @param emitter DiagnosticEmitter
* @returns return true if emitter have `category` message
*/
export function hasMessage(emitter, category) {
    const diagnostics = emitter.diagnostics ? emitter.diagnostics : [];
    for (const msg of diagnostics) {
        if (msg.category === category) {
            return true;
        }
    }
    return false;
}
let isStdlibRegex = /\~lib\/(?:array|arraybuffer|atomics|builtins|crypto|console|compat|dataview|date|diagnostics|error|function|iterator|map|math|number|object|process|reference|regexp|set|staticarray|string|symbol|table|typedarray|vector|rt\/?|bindings\/|shared\/typeinfo)|util\/|uri|polyfills|memory/;
export function isStdlib(s) {
    let source = s instanceof Source ? s : s.range.source;
    return isStdlibRegex.test(source.internalPath);
}
export const indent = util.indent;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidXRpbHMuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi9zcmMvdXRpbHMudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUEsT0FBTyxFQUdMLG9CQUFvQixFQUNwQixNQUFNLEVBRU4sVUFBVSxFQUVWLGdCQUFnQixFQUNoQixRQUFRLEVBQ1IsUUFBUSxFQUNSLG9CQUFvQixFQUNwQixtQkFBbUIsRUFDbkIsUUFBUSxFQUNSLGtCQUFrQixFQUVsQixhQUFhLEVBRWIsSUFBSSxHQUNMLE1BQU0sdUNBQXVDLENBQUM7QUFDL0MsT0FBTyxFQUFFLFVBQVUsRUFBRSxNQUFNLGlCQUFpQixDQUFDO0FBQzdDLE9BQU8sU0FBUyxNQUFNLGtCQUFrQixDQUFDO0FBRXpDLHdFQUF3RTtBQUV4RSxNQUFNLFVBQVUsU0FBUyxDQUFDLElBQW1CLEVBQUUsSUFBWTtJQUN6RCxPQUE4QixJQUFJLENBQUMsSUFBSyxDQUFDLElBQUksS0FBSyxJQUFJLENBQUM7QUFDekQsQ0FBQztBQUVELE1BQU0sVUFBVSxXQUFXLENBQUMsSUFBWTtJQUN0QyxPQUFPLENBQUMsSUFBSSxFQUFFLEVBQUUsQ0FBQyxTQUFTLENBQUMsSUFBSSxFQUFFLElBQUksQ0FBQyxDQUFDO0FBQ3pDLENBQUM7QUFHRCxNQUFNLFVBQVUsWUFBWSxDQUMxQixJQUFnRSxFQUNoRSxJQUFZO0lBRVosSUFBSSxJQUFJLENBQUM7SUFDVCxJQUFJLElBQUksWUFBWSxvQkFBb0IsRUFBRTtRQUN4QyxJQUFJLEdBQUcsSUFBSSxDQUFDO0tBQ2I7U0FBTTtRQUNMLElBQUksR0FBRyxJQUFJLENBQUMsV0FBVyxDQUFDO0tBQ3pCO0lBQ0QsZ0NBQWdDO0lBQ2hDLE9BQU8sSUFBSSxDQUFDLFVBQVUsRUFBRSxJQUFJLENBQUMsV0FBVyxDQUFDLElBQUksQ0FBQyxDQUFDLElBQUksSUFBSSxDQUFDO0FBQzFELENBQUM7QUFFRCxNQUFNLFVBQVUsWUFBWSxDQUMxQixJQUEwQixFQUMxQixJQUFZO0lBRVosT0FB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TSxDQUFDO0lBQ3RELE9BQU8sYUFBYSxDQUFDLElBQUksQ0FBQyxNQUFNLENBQUMsWUFBWSxDQUFDLENBQUM7QUFDakQsQ0FBQztBQUVELE1BQU0sQ0FBQyxNQUFNLE1BQU0sR0FBRyxJQUFJLENBQUMsTUFBTSxDQUFDIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHtcclxuICBEZWNvcmF0b3JOb2RlLFxyXG4gIElkZW50aWZpZXJFeHByZXNzaW9uLFxyXG4gIERlY2xhcmF0aW9uU3RhdGVtZW50LFxyXG4gIFNvdXJjZSxcclxuICBOb2RlLFxyXG4gIFNvdXJjZUtpbmQsXHJcbiAgUHJvZ3JhbSxcclxuICBDbGFzc0RlY2xhcmF0aW9uLFxyXG4gIFR5cGVOb2RlLFxyXG4gIE5vZGVLaW5kLFxyXG4gIEludGVyZmFjZURlY2xhcmF0aW9uLFxyXG4gIEZ1bmN0aW9uRGVjbGFyYXRpb24sXHJcbiAgVHlwZU5hbWUsXHJcbiAgRGlhZ25vc3RpY0NhdGVnb3J5LFxyXG4gIERpYWdub3N0aWNFbWl0dGVyLFxyXG4gIE5hbWVkVHlwZU5vZGUsXHJcbiAgUmFuZ2UsXHJcbiAgdXRpbCxcclxufSBmcm9tIFwiYXNzZW1ibHlzY3JpcHQvZGlzdC9hc3NlbWJseXNjcmlwdC5qc1wiO1xyXG5pbXBvcnQgeyBBU1RCdWlsZGVyIH0gZnJvbSBcIi4vYXN0QnVpbGRlci5qc1wiO1xyXG5pbXBvcnQgY2xvbmVEZWVwIGZyb20gXCJsb2Rhc2guY2xvbmVkZWVwXCI7XHJcblxyXG4vLyBjb25zdCBjbG9uZURlZXA6IDxUPih0OiBUKSA9PiBUID0gcmVxdWlyZShcImxvZGFzaC5jbG9uZWRlZXBcIikgYXMgYW55O1xyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIGRlY29yYXRlcyhub2RlOiBEZWNvcmF0b3JOb2RlLCBuYW1lOiBzdHJpbmcpOiBib29sZWFuIHtcclxuICByZXR1cm4gKDxJZGVudGlmaWVyRXhwcmVzc2lvbj5ub2RlLm5hbWUpLnRleHQgPT09IG5hbWU7XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBpc0RlY29yYXRvcihuYW1lOiBzdHJpbmcpOiAobm9kZTogRGVjb3JhdG9yTm9kZSkgPT4gYm9vbGVhbiB7XHJcbiAgcmV0dXJuIChub2RlKSA9PiBkZWNvcmF0ZXMobm9kZSwgbmFtZSk7XHJcbn1cclxuXHJcblxyXG5leHBvcnQgZnVuY3Rpb24gaGFzRGVjb3JhdG9yKFxyXG4gIG5vZGU6IERlY2xhcmF0aW9uU3RhdGVtZW50IHwge2RlY2xhcmF0aW9uOiBEZWNsYXJhdGlvblN0YXRlbWVudH0sXHJcbiAgbmFtZTogc3RyaW5nXHJcbik6IGJvb2xlYW4ge1xyXG4gIGxldCBkZWNsO1xyXG4gIGlmIChub2RlIGluc3RhbmNlb2YgRGVjbGFyYXRpb25TdGF0ZW1lbnQpIHtcclxuICAgIGRlY2wgPSBub2RlO1xyXG4gIH0gZWxzZSB7XHJcbiAgICBkZWNsID0gbm9kZS5kZWNsYXJhdGlvbjsgXHJcbiAgfSBcclxuICAvLyBiZWNhdXNlIGl0IGNvdWxkIGJlIHVuZGVmaW5lZFxyXG4gIHJldHVybiBkZWNsLmRlY29yYXRvcnM/LnNvbWUoaXNEZWNvcmF0b3IobmFtZSkpID09IHRydWU7XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBnZXREZWNvcmF0b3IoXHJcbiAgbm9kZTogRGVjbGFyYXRpb25TdGF0ZW1lbnQsXHJcbiAgbmFtZTogc3RyaW5nXHJcbik6IERlY29yYXRvck5vZGUge1xyXG4gIHJldHVybiBub2RlLmRlY29yYXRvcnM/LmZpbmQoaXNEZWNvcmF0b3IobmFtZSkpITtcclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIGlzTGlicmFyeShub2RlOiBTb3VyY2UpOiBib29sZWFuIHtcclxuICByZXR1cm4gbm9kZS5pc0xpYnJhcnkgfHwgbm9kZS5pbnRlcm5hbFBhdGguc3RhcnRzV2l0aChcIn5saWIvcnQvXCIpO1xyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gbm90PFQ+KGZuOiAodDogVCkgPT4gYm9vbGVhbik6ICh0OiBUKSA9PiBib29sZWFuIHtcclxuICByZXR1cm4gKHQ6IFQpID0+ICFmbih0KTtcclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIHRvU3RyaW5nKG5vZGU6IE5vZGUpOiBzdHJpbmcge1xyXG4gIHJldHVybiBBU1RCdWlsZGVyLmJ1aWxkKG5vZGUpO1xyXG59XHJcblxyXG5pbnRlcmZhY2UgTmFtZWQge1xyXG4gIG5hbWU6IElkZW50aWZpZXJFeHByZXNzaW9uO1xyXG59XHJcblxyXG5jb25zdCBPUl9OVUxMID0gL1xcfC4qbnVsbC87XHJcblxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIGdldE5hbWUobm9kZTogTm9kZSAmIE5hbWVkIHwgVHlwZU5vZGUpOiBzdHJpbmcge1xyXG4gIGlmIChub2RlIGluc3RhbmNlb2YgVHlwZU5vZGUpIHtcclxuICAgIGlmIChub2RlIGluc3RhbmNlb2YgTmFtZWRUeXBlTm9kZSkge1xyXG4gICAgICBsZXQgbmFtZSA9IGdldFR5cGVOYW1lKG5vZGUubmFtZSlcclxuICAgICAgY29uc3QgdHlwZVBhcmFtZXRlcnMgPSBub2RlLnR5cGVBcmd1bWVudHM7XHJcbiAgICAgIGlmICh0eXBlUGFyYW1ldGVycyAmJiB0eXBlUGFyYW1ldGVycy5sZW5ndGggPiAwKSB7XHJcbiAgICAgICAgbmFtZSArPSBgPCR7dHlwZVBhcmFtZXRlcnMubWFwKGdldE5hbWUpLmpvaW4oXCIsIFwiKX0+YDtcclxuICAgICAgfVxyXG4gICAgICBpZiAobm9kZS5pc051bGxhYmxlICYmICFPUl9OVUxMLnRlc3QobmFtZSkpIHtcclxuICAgICAgICBuYW1lID0gYCR7bmFtZX0gfCBudWxsYDtcclxuICAgICAgfVxyXG4gICAgICByZXR1cm4gbmFtZVxyXG4gICAgfSBlbHNlIGlmIChub2RlIGluc3RhbmNlb2YgVHlwZU5hbWUpIHtcclxuICAgICAgcmV0dXJuIHRvU3RyaW5nKG5vZGUuaWRlbnRpZmllcilcclxuICAgIH1cclxuICAgIHJldHVybiBcIlwiO1xyXG4gIH1cclxuICBpZiAobm9kZSBpbnN0YW5jZW9mIENsYXNzRGVjbGFyYXRpb24gfHwgbm9kZSBpbnN0YW5jZW9mIEludGVyZmFjZURlY2xhcmF0aW9uIHx8IG5vZGUgaW5zdGFuY2VvZiBGdW5jdGlvbkRlY2xhcmF0aW9uKSB7XHJcbiAgICByZXR1cm4gY2xhc3NOYW1lKG5vZGUpO1xyXG4gIH1cclxuICByZXR1cm4gdG9TdHJpbmcobm9kZS5uYW1lKTtcclxufVxyXG5cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBnZXRUeXBlTmFtZShub2RlOiBUeXBlTmFtZSk6IHN0cmluZyB7XHJcbiAgY29uc3QgcGFydE5hbWVzID0gW107XHJcbiAgbGV0IGN1cnJlbnROb2RlOiBUeXBlTmFtZSB8IG51bGwgPSBub2RlO1xyXG4gIHdoaWxlIChjdXJyZW50Tm9kZSkge1xyXG4gICAgcGFydE5hbWVzLnB1c2godG9TdHJpbmcoY3VycmVudE5vZGUuaWRlbnRpZmllcikpO1xyXG4gICAgY3VycmVudE5vZGUgPSBjdXJyZW50Tm9kZS5uZXh0O1xyXG4gIH1cclxuICByZXR1cm4gcGFydE5hbWVzLmpvaW4oXCIuXCIpO1xyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gY2xvbmVOb2RlPFQgZXh0ZW5kcyBOb2RlPihub2RlOiBUKTogVCB7XHJcbiAgcmV0dXJuIGNsb25lRGVlcChub2RlKTtcclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIGlzVXNlckVudHJ5KG5vZGU6IE5vZGUpOiBib29sZWFuIHtcclxuICByZXR1cm4gbm9kZS5yYW5nZS5zb3VyY2Uuc291cmNlS2luZCA9PSBTb3VyY2VLaW5kLlVTRVJfRU5UUlk7XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBpc0VudHJ5KG5vZGU6IE5vZGUpOiBib29sZWFuIHtcclxuICByZXR1cm4gaXNVc2VyRW50cnkobm9kZSkgfHwgbm9kZS5yYW5nZS5zb3VyY2Uuc291cmNlS2luZCA9PSBTb3VyY2VLaW5kLkxJQlJBUllfRU5UUlk7XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBjbGFzc05hbWUoX2NsYXNzOiBDbGFzc0RlY2xhcmF0aW9uIHwgIEludGVyZmFjZURlY2xhcmF0aW9uIHwgRnVuY3Rpb25EZWNsYXJhdGlvbik6IHN0cmluZyB7XHJcbiAgbGV0IG5hbWUgPSB0b1N0cmluZyhfY2xhc3MubmFtZSlcclxuICBjb25zdCB0eXBlUGFyYW1ldGVycyA9IF9jbGFzcy50eXBlUGFyYW1ldGVycztcclxuICBpZiAodHlwZVBhcmFtZXRlcnMpIHtcclxuICAgIG5hbWUgKz0gYDwke3R5cGVQYXJhbWV0ZXJzLm1hcChnZXROYW1lKS5qb2luKFwiLCBcIil9PmA7XHJcbiAgfVxyXG4gIHJldHVybiBuYW1lO1xyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gaXNNZXRob2ROYW1lZChuYW1lOiBzdHJpbmcpOiAoXzogRGVjbGFyYXRpb25TdGF0ZW1lbnQpID0+IGJvb2xlYW4ge1xyXG4gIHJldHVybiAoc3RtdDogRGVjbGFyYXRpb25TdGF0ZW1lbnQpID0+IHN0bXQua2luZCA9PSBOb2RlS2luZC5NRVRIT0RERUNMQVJBVElPTiAmJiB0b1N0cmluZyhzdG10Lm5hbWUpID09PSBuYW1lO1xyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gdXBkYXRlU291cmNlKHByb2dyYW06IFByb2dyYW0sIG5ld1NvdXJjZTogU291cmNlKSB7XHJcbiAgY29uc3Qgc291cmNlcyA9IHByb2dyYW0uc291cmNlcztcclxuICBmb3IgKGxldCBpID0gMCwgbGVuID0gc291cmNlcy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xyXG4gICAgICBpZiAoc291cmNlc1tpXS5pbnRlcm5hbFBhdGggPT0gbmV3U291cmNlLmludGVybmFsUGF0aCkge1xyXG4gICAgICAgICAgc291cmNlc1tpXSA9IG5ld1NvdXJjZTtcclxuICAgICAgICAgIGJyZWFrO1xyXG4gICAgICB9XHJcbiAgfVxyXG59XHJcblxyXG5leHBvcnQgY2xhc3MgU3RyaW5nQnVpbGRlciB7XHJcbiAgcHJpdmF0ZSBzYjogc3RyaW5nW10gPSBbXTtcclxuXHJcbiAgcHVzaChzOiBzdHJpbmcpOiB2b2lkIHtcclxuICAgIHRoaXMuc2IucHVzaChzKTtcclxuICB9XHJcblxyXG4gIGZpbmlzaChzZXBhcmF0b3IgPSBcIlxcblwiKTogc3RyaW5nIHtcclxuICAgIGxldCByZXMgPSB0aGlzLnNiLmpvaW4oc2VwYXJhdG9yKTtcclxuICAgIHRoaXMuc2IgPSBbXTtcclxuICAgIHJldHVybiByZXM7XHJcbiAgfVxyXG5cclxuICBnZXQgIGxhc3QoKTogc3RyaW5nIHsgcmV0dXJuIHRoaXMuc2JbdGhpcy5zYi5sZW5ndGggLTFdfVxyXG59XHJcblxyXG4vKipcclxuICpcclxuICogQHBhcmFtIGVtaXR0ZXIgRGlhZ25vc3RpY0VtaXR0ZXJcclxuICogQHJldHVybnMgcmV0dXJuIHRydWUgaWYgZW1pdHRlciBoYXZlIEVSUk9SIG1lc3NhZ2VcclxuICovXHJcbiBleHBvcnQgZnVuY3Rpb24gaGFzRXJyb3JNZXNzYWdlKGVtaXR0ZXI6IERpYWdub3N0aWNFbWl0dGVyKTogYm9vbGVhbiB7XHJcbiAgcmV0dXJuIGhhc01lc3NhZ2UoZW1pdHRlciwgRGlhZ25vc3RpY0NhdGVnb3J5LkVSUk9SKTtcclxufVxyXG5cclxuLyoqXHJcbipcclxuKiBAcGFyYW0gZW1pdHRlciBEaWFnbm9zdGljRW1pdHRlclxyXG4qIEByZXR1cm5zIHJldHVybiB0cnVlIGlmIGVtaXR0ZXIgaGF2ZSBXQVJOSU5HIG1lc3NhZ2VcclxuKi9cclxuZXhwb3J0IGZ1bmN0aW9uIGhhc1dhcm5pbmdNZXNzYWdlKGVtaXR0ZXI6IERpYWdub3N0aWNFbWl0dGVyKTogYm9vbGVhbiB7XHJcbiAgcmV0dXJuIGhhc01lc3NhZ2UoZW1pdHRlciwgRGlhZ25vc3RpY0NhdGVnb3J5LldBUk5JTkcpO1xyXG59XHJcblxyXG4vKipcclxuKlxyXG4qIEBwYXJhbSBlbWl0dGVyIERpYWdub3N0aWNFbWl0dGVyXHJcbiogQHJldHVybnMgcmV0dXJuIHRydWUgaWYgZW1pdHRlciBoYXZlIGBjYXRlZ29yeWAgbWVzc2FnZVxyXG4qL1xyXG5leHBvcnQgZnVuY3Rpb24gaGFzTWVzc2FnZShcclxuICBlbWl0dGVyOiBEaWFnbm9zdGljRW1pdHRlcixcclxuICBjYXRlZ29yeTogRGlhZ25vc3RpY0NhdGVnb3J5XHJcbik6IGJvb2xlYW4ge1xyXG4gIGNvbnN0IGRpYWdub3N0aWNzID0gZW1pdHRlci5kaWFnbm9zdGljcyA/IGVtaXR0ZXIuZGlhZ25vc3RpY3MgOiBbXTtcclxuICBmb3IgKGNvbnN0IG1zZyBvZiBkaWFnbm9zdGljcykge1xyXG4gICAgICBpZiAobXNnLmNhdGVnb3J5ID09PSBjYXRlZ29yeSkge1xyXG4gICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgIH1cclxuICB9XHJcbiAgcmV0dXJuIGZhbHNlO1xyXG59XHJcblxyXG5cclxubGV0IGlzU3RkbGliUmVnZXggPVxyXG4gIC9cXH5saWJcXC8oPzphcnJheXxhcnJheWJ1ZmZlcnxhdG9taWNzfGJ1aWx0aW5zfGNyeXB0b3xjb25zb2xlfGNvbXBhdHxkYXRhdmlld3xkYXRlfGRpYWdub3N0aWNzfGVycm9yfGZ1bmN0aW9ufGl0ZXJhdG9yfG1hcHxtYXRofG51bWJlcnxvYmplY3R8cHJvY2Vzc3xyZWZlcmVuY2V8cmVnZXhwfHNldHxzdGF0aWNhcnJheXxzdHJpbmd8c3ltYm9sfHRhYmxlfHR5cGVkYXJyYXl8dmVjdG9yfHJ0XFwvP3xiaW5kaW5nc1xcL3xzaGFyZWRcXC90eXBlaW5mbyl8dXRpbFxcL3x1cml8cG9seWZpbGxzfG1lbW9yeS87XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gaXNTdGRsaWIoczogU291cmNlIHwgeyByYW5nZTogUmFuZ2UgfSk6IGJvb2xlYW4ge1xyXG4gIGxldCBzb3VyY2UgPSBzIGluc3RhbmNlb2YgU291cmNlID8gcyA6IHMucmFuZ2Uuc291cmNlO1xyXG4gIHJldHVybiBpc1N0ZGxpYlJlZ2V4LnRlc3Qoc291cmNlLmludGVybmFsUGF0aCk7XHJcbn1cclxuXHJcbmV4cG9ydCBjb25zdCBpbmRlbnQgPSB1dGlsLmluZGVudDtcclxuIl19